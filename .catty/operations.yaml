# Catty Operations Model
# Version: 1.0.0
# Purpose: Formal, machine-readable operational skeleton defining complete task/artifact system
# This is the execution contract between human specifications and coding agent implementation

metadata:
  version: "1.0.1"
  project: "Catty"
  description: "Categorical modeling of formal logics with comprehensive RDF/OWL knowledge graphs"
  repository_root: "/home/engine/project"
  operations_directory: ".catty"
  created: "2025-01-02"
  last_updated: "2025-01-03"
  
  semantic_web_technologies:
    description: "Semantic web standards and technologies used in Catty project"
    
    rdf_owl:
      format: "JSON-LD"
      standards: ["RDF 1.1", "OWL 2", "JSON-LD 1.1"]
      ontology_files:
        - "ontology/catty-categorical-schema.jsonld"
        - "ontology/logics-as-objects.jsonld"
        - "ontology/morphism-catalog.jsonld"
        - "ontology/two-d-lattice-category.jsonld"
        - "ontology/curry-howard-categorical-model.jsonld"
        - "ontology/catty-complete-example.jsonld"
      linked_open_data:
        wikidata:
          usage: "owl:sameAs links to logic and category theory entities"
          license: "CC0 (Public Domain)"
          example: "wd:Q17232 (classical logic)"
        dbpedia:
          usage: "dct:source references for definitions"
          license: "CC BY-SA 3.0"
        ncatlab:
          usage: "prov:wasDerivedFrom for categorical concepts"
          license: "CC BY-SA 3.0"
          note: "nLab is primary reference for category theory definitions"
    
    shacl_validation:
      standard: "SHACL (Shapes Constraint Language) W3C Recommendation"
      shapes:
        ontology_validation: "ontology/catty-shapes.ttl"
        operational_validation: ".catty/validation/shapes/*.shacl"
      library: "pyshacl (Python)"
      purpose: "Validate RDF graphs against structural constraints"
      shape_count: 6
      coverage:
        - "Categorical schema validation (Category, Object, Morphism, Logic, Functor)"
        - "Logic instance validation (required properties, structural rules)"
        - "Morphism validation (domain/codomain constraints)"
        - "Lattice validation (coordinate ranges, uniqueness, transitivity)"
        - "Curry-Howard validation (equivalence constraints)"
        - "Complete example validation (minimum counts, completeness)"
    
    sparql_queries:
      standard: "SPARQL 1.1 Query Language"
      documentation: "ontology/queries/sparql-examples.md"
      query_count: "15+ example queries"
      categories:
        - "Basic queries (list logics, morphisms, rules)"
        - "Morphism queries (relationships, lattice order)"
        - "Adjoint relationships"
        - "Curry-Howard mappings"
        - "Lattice navigation"
        - "Validation queries"
      frameworks_shown: ["Apache Jena ARQ", "RDF4J", "rdflib (Python)", "Apache Jena (Java)"]
      note: "Documentation and examples only; executable benchmarks removed in favor of operational model validation"
    
    deployment:
      github_pages:
        format: "HTML5 + PDF"
        source: "LaTeX converted via Pandoc"
        url_pattern: "https://metavacua.github.io/CategoricalReasoner/"
        artifacts: ["index.html", "main.pdf"]
      triplestore:
        status: "Not deployed"
        note: "docker-compose.yml (Blazegraph) removed; triplestore deployment not part of core thesis deliverables"
        rationale: "Focus on thesis and semantic web standards compliance, not production deployment"

# ==============================================================================
# PART 1: ARTIFACT REGISTRY
# ==============================================================================
# Every artifact the project produces with complete specifications

artifacts:
  # --------------------------------------------------------------------------
  # Foundation Artifacts (Phase 0)
  # --------------------------------------------------------------------------
  
  repository-structure:
    artifact_id: "repository-structure"
    path: "/"
    format: "directory-tree"
    content_spec:
      - "thesis/ directory with main.tex, preamble.tex, chapters/, Makefile"
      - "ontology/ directory with *.jsonld, *.ttl, shapes/, queries/"
      - "scripts/ directory for utility scripts"
      - ".github/workflows/ for CI/CD"
      - ".catty/ for operational model"
      - "README.md, LICENSE, .gitignore at root"
    produces_from: ["task:init-repository-structure"]
    consumed_by: ["task:build-all-artifacts"]
    validation:
      type: "filesystem"
      criteria:
        - "path thesis/ exists and is directory"
        - "path ontology/ exists and is directory"
        - "path .catty/ exists and is directory"
        - "file README.md exists"
        - "file LICENSE exists"
        - "file .gitignore exists"

  catty-categorical-schema:
    artifact_id: "catty-categorical-schema"
    path: "ontology/catty-categorical-schema.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/categorical-schema.shacl"
    content_spec:
      - "JSON-LD @context with catty, rdf, rdfs, owl, skos, dct prefixes"
      - "Core categorical classes: Category, Object, Morphism, Composition"
      - "Functor, NaturalTransformation, AdjointFunctors classes"
      - "Logic-specific classes: Logic, LogicalTheory, LogicalSignature, LogicalAxiom, TheoreticalAxiom"
      - "Structural rule classes: WeakeningLHS, WeakeningRHS, ContractionLHS, ContractionRHS, Exchange"
      - "Morphism types: Extension, Interpretation, AddLEM, AddLNC, AddExplosion, AddStructuralRule"
      - "Curry-Howard classes: CurryHowardEquivalence, LogicAsCategory, TypeTheoryAsCategory"
      - "Properties: domain, codomain, source, target, composition, identity"
      - "All classes have rdfs:label, rdfs:comment, dct:description"
    produces_from: ["task:build-categorical-schema"]
    consumed_by: ["task:build-logics-as-objects", "task:build-morphism-catalog", "task:validate-ontology"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/categorical-schema.shacl"
      criteria:
        - "valid JSON-LD syntax (parse without error)"
        - "contains @context with required prefixes"
        - "defines all required classes (Category, Object, Morphism, Logic, Functor)"
        - "all classes have rdfs:label and rdfs:comment"
        - "validates against categorical-schema.shacl"

  logics-as-objects:
    artifact_id: "logics-as-objects"
    path: "ontology/logics-as-objects.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/logics-as-objects.shacl"
    content_spec:
      - "JSON-LD @context referencing catty-categorical-schema"
      - "Logic instances: LM, LK, LJ, LDJ, LL, ALL, RLL (minimum 7)"
      - "Each logic has: rdf:type catty:Logic"
      - "Each logic has: rdfs:label, dct:description"
      - "Each logic has: catty:hasLogicalSignature (connectives list)"
      - "Each logic has: catty:hasLogicalAxiom (LEM/LNC/Explosion/DNE booleans or references)"
      - "Each logic has: catty:hasWeakeningLHS, catty:hasWeakeningRHS (boolean)"
      - "Each logic has: catty:hasContractionLHS, catty:hasContractionRHS (boolean)"
      - "Each logic has: catty:hasExchange (boolean)"
      - "Each logic has: owl:sameAs link to Wikidata (if available)"
      - "Each logic has: dct:source link to Wikipedia or reference (if available)"
    produces_from: ["task:build-logics-as-objects"]
    consumed_by: ["task:build-morphism-catalog", "task:build-two-d-lattice", "task:write-audit-chapter"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/logics-as-objects.shacl"
      criteria:
        - "valid JSON-LD syntax"
        - "at least 7 logic instances defined"
        - "each logic has all required properties (label, description, signature, axioms, rules)"
        - "boolean properties are xsd:boolean or recognized values (true/false)"
        - "validates against logics-as-objects.shacl"

  morphism-catalog:
    artifact_id: "morphism-catalog"
    path: "ontology/morphism-catalog.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/morphism-catalog.shacl"
    content_spec:
      - "JSON-LD @context referencing catty-categorical-schema"
      - "Morphism instances between logics (minimum 10)"
      - "Each morphism has: rdf:type catty:LogicMorphism (or subclass like Extension, Interpretation)"
      - "Each morphism has: rdfs:label, dct:description"
      - "Each morphism has: catty:domain (source logic URI)"
      - "Each morphism has: catty:codomain (target logic URI)"
      - "Morphism types: Extension (LM→LJ, LM→LDJ, LJ→LK, LDJ→LK, LL→ALL, LL→RLL, ALL→LK, RLL→LK)"
      - "Morphism types: Interpretation (LK→LJ via double negation)"
      - "Morphism types: AdjointFunctor pairs (LK ↔ LJ)"
      - "Each morphism has: dct:source (reference or citation)"
    produces_from: ["task:build-morphism-catalog"]
    consumed_by: ["task:build-two-d-lattice", "task:write-audit-chapter"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/morphism-catalog.shacl"
      criteria:
        - "valid JSON-LD syntax"
        - "at least 10 morphism instances defined"
        - "each morphism has domain and codomain referencing valid logic URIs"
        - "each morphism has label and description"
        - "validates against morphism-catalog.shacl"

  two-d-lattice-category:
    artifact_id: "two-d-lattice-category"
    path: "ontology/two-d-lattice-category.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/two-d-lattice-category.shacl"
    content_spec:
      - "JSON-LD @context referencing catty-categorical-schema"
      - "Lattice formalized as poset category"
      - "Two axes defined: SequentRestrictionAxis (horizontal), StructuralRuleAxis (vertical)"
      - "Lattice nodes (minimum 10) with properties: latticeX, latticeY coordinates"
      - "Each node linked to Logic instance"
      - "Lattice order relations: catty:latticeOrder (≤) between nodes"
      - "Meet and join operations defined"
      - "Sublattices identified: IntuitionisticSublattice, SubstructuralSublattice"
      - "Categorical properties: completeness, distributivity"
      - "SPARQL-compatible coordinate system (x in [0,2], y in [0,10])"
    produces_from: ["task:build-two-d-lattice"]
    consumed_by: ["task:build-curry-howard-model", "task:write-audit-chapter"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/two-d-lattice-category.shacl"
      criteria:
        - "valid JSON-LD syntax"
        - "at least 10 lattice nodes defined"
        - "each node has latticeX and latticeY integer coordinates"
        - "latticeX values in range [0, 2]"
        - "latticeY values in range [0, 10]"
        - "lattice order relations are transitive (validated via SPARQL)"
        - "validates against two-d-lattice-category.shacl"

  curry-howard-categorical-model:
    artifact_id: "curry-howard-categorical-model"
    path: "ontology/curry-howard-categorical-model.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/curry-howard-model.shacl"
    content_spec:
      - "JSON-LD @context referencing catty-categorical-schema"
      - "CurryHowardEquivalence instances: LogicAsCategory ↔ TypeTheoryAsCategory"
      - "Functor: LogicToTypeTheory with domain and codomain categories"
      - "Inverse Functor: TypeTheoryToLogic"
      - "Type theory instances: STLC, System F, Linear Types, Affine Types"
      - "Natural transformations: ProofToProgram, ProgramToProof"
      - "Categorical semantics mappings: LJ ↔ CCC, LL ↔ *-Autonomous"
      - "Extension to full logic lattice with multiple type systems"
      - "Each equivalence has: source logic, target type theory, functor references"
    produces_from: ["task:build-curry-howard-model"]
    consumed_by: ["task:write-audit-chapter", "task:build-complete-example"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/curry-howard-model.shacl"
      criteria:
        - "valid JSON-LD syntax"
        - "at least 4 CurryHowardEquivalence instances"
        - "each equivalence has logic source and type theory target"
        - "functors defined with domain and codomain"
        - "validates against curry-howard-model.shacl"

  catty-complete-example:
    artifact_id: "catty-complete-example"
    path: "ontology/catty-complete-example.jsonld"
    format: "JSON-LD"
    schema: ".catty/validation/shapes/complete-example.shacl"
    content_spec:
      - "JSON-LD @context with all Catty namespaces"
      - "Self-contained example with minimum 6 logics (LK, LJ, LL, ALL, RLL, LDJ)"
      - "All structural rules defined (Weakening, Contraction, Exchange)"
      - "Minimum 10 morphisms showing lattice order"
      - "Adjoint relationships (e.g., LK ↔ LJ)"
      - "Curry-Howard correspondence examples"
      - "Fully documented with rdfs:label and dct:description for all entities"
      - "External links (owl:sameAs to Wikidata, dct:source to references)"
      - "Demonstrates complete categorical structure"
    produces_from: ["task:build-complete-example"]
    consumed_by: ["task:write-audit-chapter", "task:validate-ontology"]
    validation:
      type: "shacl"
      shape_file: ".catty/validation/shapes/complete-example.shacl"
      criteria:
        - "valid JSON-LD syntax"
        - "at least 6 logic instances"
        - "at least 10 morphism instances"
        - "all structural rules defined"
        - "demonstrates complete categorical structure (objects, morphisms, composition)"
        - "validates against complete-example.shacl"

  catty-shapes:
    artifact_id: "catty-shapes"
    path: "ontology/catty-shapes.ttl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL shapes for all major classes (Logic, LogicMorphism, Functor, Category, Object)"
      - "Property constraints: minCount, maxCount, datatype, class"
      - "NodeShape for Logic with required properties: label, description, signature, axioms, rules"
      - "NodeShape for LogicMorphism with required properties: domain, codomain"
      - "SPARQL-based constraints: lattice coordinate validation (x in [0,2], y in [0,10])"
      - "SPARQL-based constraints: lattice morphism order (domain ≤ codomain)"
      - "SPARQL-based constraints: valid lattice positions"
      - "Enables validation of Catty ontology integrity"
    produces_from: ["task:build-shacl-shapes"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax (parse without error)"
        - "contains SHACL shapes for Logic, LogicMorphism, Functor"
        - "uses sh:NodeShape, sh:property, sh:datatype, sh:minCount"
        - "includes SPARQL-based constraints (sh:sparql)"

  ontological-inventory:
    artifact_id: "ontological-inventory"
    path: "ontology/ontological-inventory.md"
    format: "Markdown"
    content_spec:
      - "Comprehensive inventory of minimum 11 external categorical resources"
      - "Each entry includes: Name, URI, Categorical constructs, License, Compatibility"
      - "Resources: DBPedia, Wikidata, OpenMath, COLORE, nLab, HoTT, Coq, Lean, Isabelle, ProofWiki, OMDoc"
      - "Each entry includes: Example usage (RDF/SPARQL), Limitations for Catty"
      - "License compatibility summary table (all must be AGPL-compatible)"
      - "Integration roadmap with 4 phases: Direct Import, Transform, Extract, Cross-Reference"
    produces_from: ["task:conduct-semantic-web-audit"]
    consumed_by: ["task:write-audit-chapter"]
    validation:
      type: "content"
      criteria:
        - "file exists and is valid Markdown"
        - "contains at least 11 resource entries"
        - "includes license compatibility table"
        - "includes 4-phase integration roadmap"
        - "all resources have URI, license, and compatibility assessment"

  sparql-examples:
    artifact_id: "sparql-examples"
    path: "ontology/queries/sparql-examples.md"
    format: "Markdown with SPARQL code blocks"
    content_spec:
      - "Minimum 15 SPARQL query examples"
      - "Basic queries: list all logics, list all morphisms, list structural rules"
      - "Morphism queries: morphisms from logic, lattice order paths"
      - "Adjoint relationships queries"
      - "Curry-Howard mapping queries"
      - "Lattice position and neighbor queries"
      - "Validation queries: orphaned logics, invalid lattice positions"
      - "Complex queries: transitive paths, composition chains"
      - "Examples for multiple frameworks: Jena ARQ, RDF4J, rdflib (Python), Apache Jena (Java)"
      - "Each query documented with purpose and expected output"
    produces_from: ["task:build-sparql-examples"]
    consumed_by: ["task:write-audit-chapter"]
    validation:
      type: "content"
      criteria:
        - "file exists and is valid Markdown"
        - "contains at least 15 SPARQL queries in code blocks"
        - "queries use correct SPARQL syntax (PREFIX, SELECT, WHERE)"
        - "covers basic, morphism, lattice, validation, and complex queries"

  ontology-readme:
    artifact_id: "ontology-readme"
    path: "ontology/README.md"
    format: "Markdown"
    content_spec:
      - "Overview of ontology structure (schema, logics, morphisms, lattice, curry-howard)"
      - "JSON-LD context documentation"
      - "Categorical model explanation"
      - "External resource integration guide"
      - "Usage examples: loading ontology, SPARQL queries, SHACL validation"
      - "Reference section with links to files and external resources"
      - "Minimum 200 lines of documentation"
    produces_from: ["task:write-ontology-documentation"]
    consumed_by: []
    validation:
      type: "content"
      criteria:
        - "file exists and is valid Markdown"
        - "contains sections: Overview, Structure, Usage, Reference"
        - "includes code examples (RDF loading, SPARQL)"
        - "minimum 150 lines"

  # --------------------------------------------------------------------------
  # Thesis Artifacts
  # --------------------------------------------------------------------------

  thesis-main:
    artifact_id: "thesis-main"
    path: "thesis/main.tex"
    format: "LaTeX"
    content_spec:
      - "LaTeX documentclass (article, report, or book)"
      - "Include preamble.tex"
      - "Document structure: begin{document} ... end{document}"
      - "Include chapters: introduction, categorical-semantic-audit, conclusions"
      - "Bibliography command"
    produces_from: ["task:init-thesis-structure"]
    consumed_by: ["task:build-thesis-pdf"]
    validation:
      type: "syntax"
      criteria:
        - "valid LaTeX syntax (parse without error)"
        - "includes documentclass"
        - "includes begin{document} and end{document}"
        - "includes chapter files via input or include"

  thesis-preamble:
    artifact_id: "thesis-preamble"
    path: "thesis/preamble.tex"
    format: "LaTeX"
    content_spec:
      - "LaTeX package imports: amsmath, amssymb, tikz-cd, listings, hyperref"
      - "Custom commands and environments"
      - "Theorem environments: theorem, lemma, definition, example"
      - "Title, author, date metadata"
    produces_from: ["task:init-thesis-structure"]
    consumed_by: ["task:build-thesis-pdf"]
    validation:
      type: "syntax"
      criteria:
        - "valid LaTeX syntax"
        - "includes usepackage commands"
        - "defines theorem environments (if needed)"

  audit-chapter:
    artifact_id: "audit-chapter"
    path: "thesis/chapters/categorical-semantic-audit.tex"
    format: "LaTeX"
    schema: ".catty/validation/thesis-structure.json"
    content_spec:
      - "LaTeX chapter: chapter{Categorical Semantic Audit}"
      - "Sections (minimum 7): Introduction, Category Theory Foundation, Logics as Objects, Morphism Catalog, Two-Dimensional Lattice, Curry-Howard Model, Reusable Ontologies, Integration Roadmap, Conclusion"
      - "Each section contains: definitions, examples, RDF/SPARQL code listings"
      - "Tables: license compatibility, resource inventory"
      - "Code listings: RDF Turtle, SPARQL queries"
      - "Citations to external resources (DBPedia, Wikidata, etc.)"
      - "Minimum 300 lines"
    produces_from: ["task:write-audit-chapter"]
    consumed_by: ["task:build-thesis-pdf"]
    validation:
      type: "structure"
      schema_file: ".catty/validation/thesis-structure.json"
      criteria:
        - "valid LaTeX syntax"
        - "contains chapter command"
        - "contains at least 7 sections"
        - "includes code listings (lstlisting or verbatim)"
        - "includes tables (tabular)"
        - "minimum 300 lines"

  introduction-chapter:
    artifact_id: "introduction-chapter"
    path: "thesis/chapters/introduction.tex"
    format: "LaTeX"
    content_spec:
      - "LaTeX chapter: chapter{Introduction}"
      - "Sections: Motivation, Categorical Framework, Thesis Structure"
      - "Overview of categorical modeling approach"
      - "Thesis roadmap"
    produces_from: ["task:write-introduction"]
    consumed_by: ["task:build-thesis-pdf"]
    validation:
      type: "syntax"
      criteria:
        - "valid LaTeX syntax"
        - "contains chapter command"
        - "contains at least 2 sections"

  conclusions-chapter:
    artifact_id: "conclusions-chapter"
    path: "thesis/chapters/conclusions.tex"
    format: "LaTeX"
    content_spec:
      - "LaTeX chapter: chapter{Conclusions}"
      - "Sections: Summary, Future Work"
      - "Summary of categorical model contributions"
      - "Future research directions"
    produces_from: ["task:write-conclusions"]
    consumed_by: ["task:build-thesis-pdf"]
    validation:
      type: "syntax"
      criteria:
        - "valid LaTeX syntax"
        - "contains chapter command"
        - "contains at least 2 sections"

  thesis-pdf:
    artifact_id: "thesis-pdf"
    path: "thesis/main.pdf"
    format: "PDF"
    content_spec:
      - "PDF compiled from main.tex"
      - "Contains all chapters: introduction, audit, conclusions"
      - "Contains bibliography"
      - "No compilation errors"
    produces_from: ["task:build-thesis-pdf"]
    consumed_by: ["task:build-github-pages-site"]
    validation:
      type: "build"
      criteria:
        - "PDF file exists"
        - "PDF is valid (can be opened)"
        - "pdflatex or latexmk compilation succeeds with exit code 0"

  # --------------------------------------------------------------------------
  # GitHub Pages Artifacts
  # --------------------------------------------------------------------------

  thesis-expanded-latex:
    artifact_id: "thesis-expanded-latex"
    path: "site/main.expanded.tex"
    format: "LaTeX"
    content_spec:
      - "LaTeX file with all includes expanded inline"
      - "Generated by latexpand from thesis/main.tex"
      - "Intermediate artifact for Pandoc HTML conversion"
      - "No \\input or \\include commands remain"
    produces_from: ["task:expand-latex"]
    consumed_by: ["task:convert-latex-to-html"]
    validation:
      type: "latex"
      criteria:
        - "file site/main.expanded.tex exists"
        - "valid LaTeX syntax"
        - "contains chapter content inline (no include commands)"
        - "grep -v '\\\\input\\|\\\\include' site/main.expanded.tex returns no matches"

  thesis-html:
    artifact_id: "thesis-html"
    path: "site/index.html"
    format: "HTML5"
    content_spec:
      - "HTML5 converted from expanded LaTeX using Pandoc"
      - "Contains all thesis chapters (Introduction, Audit, Conclusions)"
      - "Semantic HTML structure with sections and headings"
      - "Deployed to GitHub Pages at https://metavacua.github.io/CategoricalReasoner/"
    produces_from: ["task:convert-latex-to-html"]
    consumed_by: ["task:build-github-pages-site"]
    validation:
      type: "html"
      criteria:
        - "file site/index.html exists"
        - "valid HTML5 syntax"
        - "contains thesis content (chapters, sections, headings)"
        - "file size > 10KB (substantial content)"

  github-pages-site:
    artifact_id: "github-pages-site"
    path: "site/"
    format: "directory"
    content_spec:
      - "Directory containing complete GitHub Pages deployment"
      - "site/index.html: HTML5 thesis"
      - "site/main.pdf: PDF thesis"
      - "Ready for upload-pages-artifact GitHub Action"
    produces_from: ["task:build-github-pages-site"]
    consumed_by: ["task:deploy-to-github-pages"]
    validation:
      type: "directory"
      criteria:
        - "directory site/ exists"
        - "file site/index.html exists and is valid HTML"
        - "file site/main.pdf exists and is valid PDF"
        - "both files are non-empty"

  github-pages-workflow:
    artifact_id: "github-pages-workflow"
    path: ".github/workflows/deploy.yml"
    format: "YAML (GitHub Actions)"
    content_spec:
      - "GitHub Actions workflow for automated deployment"
      - "Trigger: workflow_dispatch (manual trigger from GitHub UI)"
      - "Jobs: build-and-deploy (builds PDF, converts to HTML, deploys)"
      - "Steps: checkout, install LaTeX/Pandoc, build PDF, expand LaTeX, convert to HTML, deploy"
      - "Uses GitHub Actions: configure-pages, upload-pages-artifact, deploy-pages"
      - "Permissions: contents:read, pages:write, id-token:write"
    produces_from: ["task:create-github-pages-workflow"]
    consumed_by: ["task:deploy-to-github-pages"]
    validation:
      type: "yaml"
      criteria:
        - "file .github/workflows/deploy.yml exists"
        - "valid YAML syntax"
        - "contains on: workflow_dispatch trigger"
        - "contains jobs with build-and-deploy"
        - "installs LaTeX, Pandoc, latexpand in workflow"
        - "uses configure-pages, upload-pages-artifact, deploy-pages actions"

  # --------------------------------------------------------------------------
  # Validation and Testing Artifacts
  # --------------------------------------------------------------------------

  validation-script:
    artifact_id: "validation-script"
    path: ".catty/validation/validate.py"
    format: "Python"
    content_spec:
      - "Python script for validating task outputs"
      - "Functions: validate_rdf(file, shape), validate_json_ld(file), validate_latex(file, structure)"
      - "Uses rdflib for RDF parsing and SHACL validation"
      - "Uses json for JSON-LD parsing"
      - "Command-line interface: python validate.py --artifact <artifact_id>"
      - "Reads operations.yaml to get artifact specs and validation criteria"
      - "Outputs: boolean pass/fail, detailed error messages"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology", "task:validate-thesis"]
    validation:
      type: "syntax"
      criteria:
        - "valid Python syntax (parse without error)"
        - "imports rdflib, json, yaml, argparse"
        - "defines validate_rdf, validate_json_ld, validate_latex functions"
        - "has if __name__ == '__main__' entry point"

  # --------------------------------------------------------------------------
  # SHACL Shape Artifacts
  # --------------------------------------------------------------------------

  categorical-schema-shape:
    artifact_id: "categorical-schema-shape"
    path: ".catty/validation/shapes/categorical-schema.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL NodeShape for catty:Category class"
      - "SHACL NodeShape for catty:Object class"
      - "SHACL NodeShape for catty:Morphism class"
      - "SHACL NodeShape for catty:Logic class"
      - "Property constraints: rdfs:label (minCount 1), rdfs:comment (minCount 1)"
      - "Datatype constraints: xsd:string for labels/comments"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL NodeShapes"
        - "uses sh:targetClass, sh:property, sh:minCount, sh:datatype"

  logics-as-objects-shape:
    artifact_id: "logics-as-objects-shape"
    path: ".catty/validation/shapes/logics-as-objects.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL NodeShape for catty:Logic instances"
      - "Required properties: rdfs:label, dct:description, catty:hasLogicalSignature"
      - "Required properties: catty:hasWeakeningLHS, catty:hasWeakeningRHS (boolean)"
      - "Required properties: catty:hasContractionLHS, catty:hasContractionRHS (boolean)"
      - "Required properties: catty:hasExchange (boolean)"
      - "Optional properties: owl:sameAs, dct:source"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL NodeShape for catty:Logic"
        - "defines required properties with minCount 1"

  morphism-catalog-shape:
    artifact_id: "morphism-catalog-shape"
    path: ".catty/validation/shapes/morphism-catalog.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL NodeShape for catty:LogicMorphism instances"
      - "Required properties: rdfs:label, dct:description"
      - "Required properties: catty:domain (must reference catty:Logic)"
      - "Required properties: catty:codomain (must reference catty:Logic)"
      - "Class constraint: catty:domain sh:class catty:Logic"
      - "Class constraint: catty:codomain sh:class catty:Logic"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL NodeShape for catty:LogicMorphism"
        - "defines domain and codomain with sh:class catty:Logic"

  two-d-lattice-shape:
    artifact_id: "two-d-lattice-shape"
    path: ".catty/validation/shapes/two-d-lattice-category.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL NodeShape for lattice nodes"
      - "Required properties: catty:latticeX, catty:latticeY (xsd:integer)"
      - "Property constraints: catty:latticeX sh:minInclusive 0, sh:maxInclusive 2"
      - "Property constraints: catty:latticeY sh:minInclusive 0, sh:maxInclusive 10"
      - "SPARQL constraint: lattice order transitivity"
      - "SPARQL constraint: valid lattice positions"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL NodeShape for lattice nodes"
        - "defines coordinate constraints (min/max inclusive)"
        - "includes SPARQL-based constraints"

  curry-howard-model-shape:
    artifact_id: "curry-howard-model-shape"
    path: ".catty/validation/shapes/curry-howard-model.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "SHACL NodeShape for catty:CurryHowardEquivalence instances"
      - "Required properties: catty:logicSource (references Logic)"
      - "Required properties: catty:typeTheoryTarget (references TypeTheory)"
      - "Required properties: catty:functor (references Functor)"
      - "Optional properties: catty:inverseFunctor"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL NodeShape for catty:CurryHowardEquivalence"
        - "defines required properties with class constraints"

  complete-example-shape:
    artifact_id: "complete-example-shape"
    path: ".catty/validation/shapes/complete-example.shacl"
    format: "RDF/Turtle (SHACL)"
    content_spec:
      - "Combined SHACL shapes for complete example validation"
      - "Validates presence of minimum 6 logics"
      - "Validates presence of minimum 10 morphisms"
      - "Validates all structural rules defined"
      - "Validates complete categorical structure (objects, morphisms, composition)"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-ontology"]
    validation:
      type: "syntax"
      criteria:
        - "valid Turtle syntax"
        - "contains SHACL constraints for complete example"

  thesis-structure-schema:
    artifact_id: "thesis-structure-schema"
    path: ".catty/validation/thesis-structure.json"
    format: "JSON Schema"
    content_spec:
      - "JSON Schema for thesis chapter structure validation"
      - "Required fields: chapter_title, sections (array), min_sections, min_lines"
      - "Section structure: section_title, subsections (optional), content_requirements"
      - "Content requirements: definitions, examples, code_listings, tables, citations"
      - "Audit chapter schema: 7+ sections, 300+ lines, code listings, tables"
    produces_from: ["task:build-validation-framework"]
    consumed_by: ["task:validate-thesis"]
    validation:
      type: "syntax"
      criteria:
        - "valid JSON Schema syntax"
        - "defines chapter structure requirements"
        - "includes audit chapter specification"

# ==============================================================================
# PART 2: TASK REGISTRY
# ==============================================================================
# Every task that produces artifacts with complete specifications

tasks:
  # --------------------------------------------------------------------------
  # Phase 0: Foundation Tasks (no external dependencies)
  # --------------------------------------------------------------------------

  init-repository-structure:
    task_id: "task:init-repository-structure"
    phase: 0
    produces: ["repository-structure"]
    depends_on: []
    description: |
      Create complete repository directory structure.
      Create directories: thesis/, thesis/chapters/, ontology/, ontology/queries/, 
      ontology/shapes/, scripts/, .github/workflows/, .catty/, .catty/validation/, 
      .catty/validation/shapes/.
      Create files: README.md (project overview), LICENSE (AGPL-3.0), 
      .gitignore (LaTeX artifacts, Python cache, PDF/HTML output).
      Do not create artifact files yet (only structure).
    acceptance_criteria:
      - "directory thesis/ exists"
      - "directory thesis/chapters/ exists"
      - "directory ontology/ exists"
      - "directory ontology/queries/ exists"
      - "directory .catty/ exists"
      - "directory .catty/validation/ exists"
      - "directory .catty/validation/shapes/ exists"
      - "file README.md exists and contains project description"
      - "file LICENSE exists and contains AGPL-3.0 text"
      - "file .gitignore exists and includes *.pdf, *.aux, __pycache__"
    validation_script: ".catty/validation/validate.py --artifact repository-structure"

  conduct-semantic-web-audit:
    task_id: "task:conduct-semantic-web-audit"
    phase: 0
    produces: ["ontological-inventory"]
    depends_on: []
    description: |
      Research and document 11+ external categorical/logic resources.
      For each resource, document: Name, URI/URL, Categorical constructs defined,
      Logic-categorical relationships, License, AGPL compatibility, Example usage
      (RDF/SPARQL if applicable), Limitations for Catty.
      Resources to include: DBPedia Category Theory, Wikidata Mathematical Ontology,
      OpenMath Content Dictionaries, COLORE, nLab, HoTT Knowledge Graph, Coq Libraries,
      Lean MathLib, Isabelle/HOL, ProofWiki, OMDoc.
      Create license compatibility summary table (all must be AGPL-compatible).
      Create 4-phase integration roadmap: Direct Import (Wikidata, DBPedia),
      Transform (OpenMath, OMDoc), Extract (Lean, Coq, Isabelle), Cross-Reference (nLab, ProofWiki).
      Output: ontology/ontological-inventory.md (minimum 500 lines).
    acceptance_criteria:
      - "file ontology/ontological-inventory.md exists"
      - "contains at least 11 resource entries"
      - "each entry has: Name, URI, Constructs, License, Compatibility, Example, Limitations"
      - "includes license compatibility table"
      - "includes 4-phase integration roadmap"
      - "all resources are AGPL-compatible"
      - "minimum 400 lines"
    validation_script: ".catty/validation/validate.py --artifact ontological-inventory"

  # --------------------------------------------------------------------------
  # Phase 1: Core Ontology Tasks (depends on Phase 0)
  # --------------------------------------------------------------------------

  build-categorical-schema:
    task_id: "task:build-categorical-schema"
    phase: 1
    produces: ["catty-categorical-schema"]
    depends_on: []
    description: |
      Create core categorical schema in JSON-LD format.
      Define @context with prefixes: catty, rdf, rdfs, owl, skos, dct, xsd.
      Define classes: Category, Object, Morphism, Composition, Functor,
      NaturalTransformation, AdjointFunctors.
      Define Logic-specific classes: Logic, LogicalTheory, LogicalSignature,
      LogicalAxiom, TheoreticalAxiom.
      Define Structural rule classes: WeakeningLHS, WeakeningRHS, ContractionLHS,
      ContractionRHS, Exchange.
      Define Morphism types: Extension, Interpretation, AddLEM, AddLNC, AddExplosion,
      AddStructuralRule.
      Define Curry-Howard classes: CurryHowardEquivalence, LogicAsCategory,
      TypeTheoryAsCategory.
      Define properties: domain, codomain, source, target, composition, identity,
      hasLogicalSignature, hasLogicalAxiom, hasStructuralRule.
      All classes must have: rdfs:label, rdfs:comment, dct:description.
      Output: ontology/catty-categorical-schema.jsonld.
    acceptance_criteria:
      - "file ontology/catty-categorical-schema.jsonld exists"
      - "valid JSON-LD syntax (parse without error)"
      - "contains @context with prefixes: catty, rdf, rdfs, owl, skos, dct, xsd"
      - "defines classes: Category, Object, Morphism, Logic, Functor, NaturalTransformation"
      - "defines structural rule classes: WeakeningLHS, WeakeningRHS, ContractionLHS, ContractionRHS, Exchange"
      - "defines morphism types: Extension, Interpretation"
      - "defines Curry-Howard classes: CurryHowardEquivalence, LogicAsCategory, TypeTheoryAsCategory"
      - "all classes have rdfs:label and rdfs:comment"
      - "validates against .catty/validation/shapes/categorical-schema.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact catty-categorical-schema"

  build-logics-as-objects:
    task_id: "task:build-logics-as-objects"
    phase: 1
    produces: ["logics-as-objects"]
    depends_on: ["catty-categorical-schema"]
    description: |
      Create logic instances as categorical objects in JSON-LD format.
      Reference @context from catty-categorical-schema.jsonld.
      Define minimum 7 logic instances: LM, LK, LJ, LDJ, LL, ALL, RLL.
      Each logic instance must have:
      - rdf:type: catty:Logic
      - rdfs:label: human-readable name (e.g., "Classical Logic")
      - dct:description: detailed description
      - catty:hasLogicalSignature: list of connectives (e.g., ["∧", "∨", "→", "¬"])
      - catty:hasLogicalAxiom: axioms (LEM, LNC, Explosion, DNE) as booleans or references
      - catty:hasWeakeningLHS: boolean (true/false)
      - catty:hasWeakeningRHS: boolean
      - catty:hasContractionLHS: boolean
      - catty:hasContractionRHS: boolean
      - catty:hasExchange: boolean
      - owl:sameAs: link to Wikidata item (if available)
      - dct:source: link to Wikipedia or reference (if available)
      Logic definitions:
      - LM: minimal logic (no LEM, no LNC, has Exchange)
      - LK: classical logic (has LEM, LNC, all structural rules)
      - LJ: intuitionistic logic (no LEM, has LNC, all structural rules)
      - LDJ: dual intuitionistic logic (has LEM, no LNC, all structural rules)
      - LL: linear logic (no LEM, no LNC, has Exchange only)
      - ALL: affine linear logic (no LEM, no LNC, has Exchange and Weakening)
      - RLL: relevant linear logic (no LEM, no LNC, has Exchange and Contraction)
      Output: ontology/logics-as-objects.jsonld.
    acceptance_criteria:
      - "file ontology/logics-as-objects.jsonld exists"
      - "valid JSON-LD syntax"
      - "at least 7 logic instances defined (LM, LK, LJ, LDJ, LL, ALL, RLL)"
      - "each logic has rdf:type catty:Logic"
      - "each logic has rdfs:label, dct:description"
      - "each logic has catty:hasLogicalSignature (array or string)"
      - "each logic has boolean structural rule properties (WeakeningLHS, WeakeningRHS, ContractionLHS, ContractionRHS, Exchange)"
      - "validates against .catty/validation/shapes/logics-as-objects.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact logics-as-objects"

  build-morphism-catalog:
    task_id: "task:build-morphism-catalog"
    phase: 1
    produces: ["morphism-catalog"]
    depends_on: ["catty-categorical-schema", "logics-as-objects"]
    description: |
      Create morphism instances between logics in JSON-LD format.
      Reference @context from catty-categorical-schema.jsonld.
      Define minimum 10 morphism instances.
      Each morphism must have:
      - rdf:type: catty:LogicMorphism (or subclass: Extension, Interpretation)
      - rdfs:label: human-readable name (e.g., "LM to LJ Extension")
      - dct:description: detailed description of morphism
      - catty:domain: URI reference to source logic
      - catty:codomain: URI reference to target logic
      - dct:source: reference or citation
      Define morphisms:
      - Extensions: LM→LJ (add LNC), LM→LDJ (add LEM), LJ→LK (add LEM),
        LDJ→LK (add LNC), LL→ALL (add Weakening), LL→RLL (add Contraction),
        ALL→LK (add Contraction and axioms), RLL→LK (add Weakening and axioms)
      - Interpretations: LK→LJ (double negation translation)
      - Adjoint functors: LK ↔ LJ (adjoint pair)
      Output: ontology/morphism-catalog.jsonld.
    acceptance_criteria:
      - "file ontology/morphism-catalog.jsonld exists"
      - "valid JSON-LD syntax"
      - "at least 10 morphism instances defined"
      - "each morphism has rdf:type catty:LogicMorphism or subclass"
      - "each morphism has rdfs:label, dct:description"
      - "each morphism has catty:domain and catty:codomain"
      - "domain and codomain URIs reference valid logic instances from logics-as-objects.jsonld"
      - "validates against .catty/validation/shapes/morphism-catalog.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact morphism-catalog"

  build-two-d-lattice:
    task_id: "task:build-two-d-lattice"
    phase: 1
    produces: ["two-d-lattice-category"]
    depends_on: ["catty-categorical-schema", "logics-as-objects", "morphism-catalog"]
    description: |
      Create two-dimensional lattice structure as poset category in JSON-LD format.
      Reference @context from catty-categorical-schema.jsonld.
      Define two axes:
      - SequentRestrictionAxis (horizontal): 3 levels (0=unrestricted, 1=left-restricted, 2=right-restricted)
      - StructuralRuleAxis (vertical): 11 levels (0-10) based on structural rule configuration
      Define minimum 10 lattice nodes with properties:
      - catty:latticeX: integer coordinate (0-2)
      - catty:latticeY: integer coordinate (0-10)
      - catty:logicInstance: URI reference to logic from logics-as-objects.jsonld
      - rdfs:label, dct:description
      Define lattice order relations:
      - catty:latticeOrder: partial order (≤) between nodes
      - Transitive closure of order relations
      Define meet and join operations for lattice.
      Define sublattices: IntuitionisticSublattice, SubstructuralSublattice.
      Define categorical properties: completeness, distributivity.
      Example node: LK at (0, 10) (unrestricted, all structural rules).
      Output: ontology/two-d-lattice-category.jsonld.
    acceptance_criteria:
      - "file ontology/two-d-lattice-category.jsonld exists"
      - "valid JSON-LD syntax"
      - "at least 10 lattice nodes defined"
      - "each node has catty:latticeX (integer 0-2) and catty:latticeY (integer 0-10)"
      - "each node has catty:logicInstance referencing valid logic URI"
      - "lattice order relations defined (catty:latticeOrder)"
      - "meet and join operations defined"
      - "sublattices defined"
      - "validates against .catty/validation/shapes/two-d-lattice-category.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact two-d-lattice-category"

  build-curry-howard-model:
    task_id: "task:build-curry-howard-model"
    phase: 1
    produces: ["curry-howard-categorical-model"]
    depends_on: ["catty-categorical-schema", "logics-as-objects", "two-d-lattice-category"]
    description: |
      Create Curry-Howard correspondence as categorical equivalence in JSON-LD format.
      Reference @context from catty-categorical-schema.jsonld.
      Define CurryHowardEquivalence instances: LogicAsCategory ↔ TypeTheoryAsCategory.
      Define functors:
      - LogicToTypeTheory: functor from logic category to type theory category
      - TypeTheoryToLogic: inverse functor
      Define minimum 4 type theory instances:
      - STLC (Simply Typed Lambda Calculus) corresponding to LJ
      - System F corresponding to second-order intuitionistic logic
      - Linear Types corresponding to LL
      - Affine Types corresponding to ALL
      Each CurryHowardEquivalence instance must have:
      - rdf:type: catty:CurryHowardEquivalence
      - catty:logicSource: URI reference to logic
      - catty:typeTheoryTarget: URI reference to type theory
      - catty:functor: URI reference to LogicToTypeTheory functor
      - catty:inverseFunctor: URI reference to TypeTheoryToLogic functor (optional)
      - rdfs:label, dct:description
      Define categorical semantics mappings:
      - LJ ↔ CCC (Cartesian Closed Category)
      - LL ↔ *-Autonomous Category
      Define natural transformations: ProofToProgram, ProgramToProof.
      Extend to full logic lattice with multiple type systems.
      Output: ontology/curry-howard-categorical-model.jsonld.
    acceptance_criteria:
      - "file ontology/curry-howard-categorical-model.jsonld exists"
      - "valid JSON-LD syntax"
      - "at least 4 CurryHowardEquivalence instances defined"
      - "each equivalence has catty:logicSource and catty:typeTheoryTarget"
      - "functors defined: LogicToTypeTheory, TypeTheoryToLogic"
      - "type theory instances: STLC, System F, Linear Types, Affine Types"
      - "categorical semantics mappings: LJ ↔ CCC, LL ↔ *-Autonomous"
      - "validates against .catty/validation/shapes/curry-howard-model.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact curry-howard-categorical-model"

  build-complete-example:
    task_id: "task:build-complete-example"
    phase: 1
    produces: ["catty-complete-example"]
    depends_on: ["catty-categorical-schema", "logics-as-objects", "morphism-catalog", "two-d-lattice-category", "curry-howard-categorical-model"]
    description: |
      Create self-contained complete example demonstrating full categorical structure in JSON-LD.
      Reference @context from catty-categorical-schema.jsonld.
      Include minimum 6 logics: LK, LJ, LL, ALL, RLL, LDJ.
      Include all structural rules: WeakeningLHS, WeakeningRHS, ContractionLHS,
      ContractionRHS, Exchange.
      Include minimum 10 morphisms showing lattice order.
      Include adjoint relationships (e.g., LK ↔ LJ).
      Include Curry-Howard correspondence examples (LJ ↔ STLC, LL ↔ Linear Types).
      All entities must have: rdfs:label, dct:description.
      Include external links: owl:sameAs to Wikidata, dct:source to references.
      Demonstrate complete categorical structure: objects, morphisms, composition,
      identity morphisms.
      Output: ontology/catty-complete-example.jsonld.
    acceptance_criteria:
      - "file ontology/catty-complete-example.jsonld exists"
      - "valid JSON-LD syntax"
      - "at least 6 logic instances (LK, LJ, LL, ALL, RLL, LDJ)"
      - "all structural rules defined"
      - "at least 10 morphism instances"
      - "adjoint relationships defined"
      - "Curry-Howard examples included"
      - "all entities have rdfs:label and dct:description"
      - "demonstrates complete categorical structure"
      - "validates against .catty/validation/shapes/complete-example.shacl (once SHACL exists)"
    validation_script: ".catty/validation/validate.py --artifact catty-complete-example"

  build-shacl-shapes:
    task_id: "task:build-shacl-shapes"
    phase: 1
    produces: ["catty-shapes"]
    depends_on: ["catty-categorical-schema"]
    description: |
      Create SHACL validation shapes for Catty ontology in Turtle format.
      Define NodeShapes for major classes:
      - Logic: required properties (label, description, signature, axioms, structural rules)
      - LogicMorphism: required properties (label, description, domain, codomain)
      - Functor: required properties (label, domain, codomain)
      - Category, Object: basic properties
      Property constraints:
      - minCount, maxCount for required/optional properties
      - datatype constraints (xsd:string, xsd:boolean, xsd:integer)
      - class constraints (e.g., domain sh:class catty:Logic)
      SPARQL-based constraints:
      - Lattice coordinate validation: latticeX in [0,2], latticeY in [0,10]
      - Lattice morphism order: domain node ≤ codomain node in lattice
      - Valid lattice positions: no duplicate coordinates
      Output: ontology/catty-shapes.ttl.
    acceptance_criteria:
      - "file ontology/catty-shapes.ttl exists"
      - "valid Turtle syntax (parse without error)"
      - "contains SHACL NodeShapes for Logic, LogicMorphism, Functor"
      - "uses sh:NodeShape, sh:property, sh:datatype, sh:minCount, sh:maxCount"
      - "includes SPARQL-based constraints (sh:sparql)"
      - "lattice coordinate constraints defined"
    validation_script: ".catty/validation/validate.py --artifact catty-shapes"

  build-sparql-examples:
    task_id: "task:build-sparql-examples"
    phase: 1
    produces: ["sparql-examples"]
    depends_on: ["logics-as-objects", "morphism-catalog", "two-d-lattice-category", "curry-howard-categorical-model"]
    description: |
      Create comprehensive SPARQL query examples in Markdown format.
      Include minimum 15 SPARQL queries with categories:
      1. Basic queries (5):
         - List all logics
         - List all morphisms
         - List all structural rules
         - Get logic details by URI
         - Count logics by type
      2. Morphism queries (3):
         - Morphisms from specific logic
         - Morphisms to specific logic
         - Lattice order paths
      3. Adjoint relationships (1):
         - Find adjoint functor pairs
      4. Curry-Howard mappings (2):
         - Logic to type theory mappings
         - Type theory to logic mappings
      5. Lattice queries (2):
         - Lattice positions of logics
         - Neighbors in lattice
      6. Validation queries (2):
         - Orphaned logics (no morphisms)
         - Invalid lattice positions
      Each query must include:
      - Query purpose/description
      - SPARQL code block with syntax highlighting
      - Expected output format
      Include examples for multiple frameworks: Jena ARQ, RDF4J, rdflib (Python),
      Apache Jena (Java).
      Output: ontology/queries/sparql-examples.md.
    acceptance_criteria:
      - "file ontology/queries/sparql-examples.md exists"
      - "valid Markdown syntax"
      - "at least 15 SPARQL queries in code blocks"
      - "queries use correct SPARQL syntax (PREFIX, SELECT, WHERE)"
      - "covers all 6 categories: basic, morphism, adjoint, curry-howard, lattice, validation"
      - "each query has purpose description"
      - "includes examples for multiple frameworks"
    validation_script: ".catty/validation/validate.py --artifact sparql-examples"

  write-ontology-documentation:
    task_id: "task:write-ontology-documentation"
    phase: 1
    produces: ["ontology-readme"]
    depends_on: ["catty-categorical-schema", "logics-as-objects", "morphism-catalog", "two-d-lattice-category", "curry-howard-categorical-model", "catty-complete-example", "catty-shapes", "sparql-examples"]
    description: |
      Create comprehensive documentation for Catty ontology in Markdown format.
      Structure:
      1. Overview (50 lines):
         - Purpose of Catty ontology
         - Categorical modeling approach
         - Ontology components overview
      2. Structure (100 lines):
         - Schema files and their purposes
         - Logic instances and properties
         - Morphism catalog
         - Two-dimensional lattice
         - Curry-Howard model
         - Complete example
         - SHACL validation
      3. JSON-LD Context (30 lines):
         - Prefix definitions
         - Namespace URIs
         - Context reuse
      4. Categorical Model (50 lines):
         - Objects (logics)
         - Morphisms (extensions, interpretations)
         - Composition and identity
         - Lattice structure
         - Curry-Howard equivalence
      5. External Resource Integration (30 lines):
         - Wikidata links (owl:sameAs)
         - Wikipedia references (dct:source)
         - Integration with external ontologies
      6. Usage Examples (80 lines):
         - Loading ontology into triplestore (Jena, RDF4J, rdflib)
         - SPARQL query examples
         - SHACL validation examples
         - Python/Java code snippets
      7. Reference (20 lines):
         - Links to all ontology files
         - Links to external resources
         - Links to thesis chapters
      Output: ontology/README.md (minimum 350 lines).
    acceptance_criteria:
      - "file ontology/README.md exists"
      - "valid Markdown syntax"
      - "contains sections: Overview, Structure, JSON-LD Context, Categorical Model, Integration, Usage, Reference"
      - "includes code examples (RDF loading, SPARQL queries, Python/Java)"
      - "minimum 300 lines"
      - "references all major ontology files"
    validation_script: ".catty/validation/validate.py --artifact ontology-readme"

  # --------------------------------------------------------------------------
  # Phase 2: Thesis Tasks (depends on ontology artifacts)
  # --------------------------------------------------------------------------

  init-thesis-structure:
    task_id: "task:init-thesis-structure"
    phase: 2
    produces: ["thesis-main", "thesis-preamble"]
    depends_on: []
    description: |
      Create basic LaTeX thesis structure.
      Create thesis/main.tex:
      - documentclass: article, report, or book
      - include preamble.tex
      - begin{document} ... end{document}
      - include chapters: introduction, categorical-semantic-audit, conclusions
      - bibliography command
      Create thesis/preamble.tex:
      - package imports: amsmath, amssymb, tikz-cd, listings, hyperref, xcolor
      - custom commands (if needed)
      - theorem environments: theorem, lemma, definition, example (using amsthm)
      - listings settings for code (RDF, SPARQL, Python)
      - title, author, date metadata
      Output: thesis/main.tex, thesis/preamble.tex.
    acceptance_criteria:
      - "file thesis/main.tex exists"
      - "file thesis/preamble.tex exists"
      - "main.tex contains documentclass, input preamble, begin/end document"
      - "main.tex includes chapter files (input or include)"
      - "preamble.tex contains usepackage commands"
      - "preamble.tex defines theorem environments (if needed)"
      - "valid LaTeX syntax (parse without error)"
    validation_script: ".catty/validation/validate.py --artifact thesis-main"

  write-introduction:
    task_id: "task:write-introduction"
    phase: 2
    produces: ["introduction-chapter"]
    depends_on: ["init-thesis-structure"]
    description: |
      Write introduction chapter for thesis in LaTeX format.
      Structure:
      - chapter{Introduction}
      - section{Motivation} (20 lines):
        - Problem: organizing formal logics systematically
        - Categorical approach advantages
        - Thesis contribution overview
      - section{Categorical Framework} (30 lines):
        - Logics as objects
        - Morphisms between logics (extensions, interpretations)
        - Two-dimensional lattice structure
        - Curry-Howard correspondence
      - section{Thesis Structure} (20 lines):
        - Chapter 1: Categorical Semantic Audit
        - Chapter 2+: Additional chapters (placeholder)
        - Conclusions
        - Ontology deliverables
      Output: thesis/chapters/introduction.tex (minimum 70 lines).
    acceptance_criteria:
      - "file thesis/chapters/introduction.tex exists"
      - "valid LaTeX syntax"
      - "contains chapter{Introduction} command"
      - "contains at least 3 sections: Motivation, Framework, Structure"
      - "minimum 60 lines"
    validation_script: ".catty/validation/validate.py --artifact introduction-chapter"

  write-audit-chapter:
    task_id: "task:write-audit-chapter"
    phase: 2
    produces: ["audit-chapter"]
    depends_on: ["catty-categorical-schema", "logics-as-objects", "morphism-catalog", "two-d-lattice-category", "curry-howard-categorical-model", "catty-complete-example", "ontological-inventory", "sparql-examples"]
    description: |
      Write comprehensive categorical semantic audit chapter for thesis in LaTeX format.
      Structure (minimum 7 sections, 350 lines total):
      1. section{Introduction} (30 lines):
         - Purpose of audit
         - Categorical modeling goals
         - Deliverables overview
      2. section{Category Theory Foundation} (50 lines):
         - Categories, objects, morphisms, composition
         - Functors and natural transformations
         - DBPedia and Wikidata RDF representations
         - Code listing: RDF example
      3. section{Logics as Categorical Objects} (60 lines):
         - Logic class definition
         - Structural rule configuration
         - 7+ logic instances (LM, LK, LJ, LDJ, LL, ALL, RLL)
         - Table: logic structural rule comparison
         - Code listing: Logic instance RDF
      4. section{Morphism Catalog} (50 lines):
         - Morphism types: extension, interpretation
         - 10+ morphism instances
         - Table: morphism catalog
         - Code listing: Morphism RDF
      5. section{Two-Dimensional Lattice as Category} (60 lines):
         - Lattice structure: horizontal (sequent), vertical (structural rules)
         - Poset category formalization
         - Lattice nodes with coordinates
         - Sublattices
         - Code listing: Lattice RDF
      6. section{Curry-Howard Categorical Model} (50 lines):
         - Equivalence of categories: logic ↔ type theory
         - Functors: LogicToTypeTheory, TypeTheoryToLogic
         - Type theory instances: STLC, System F, Linear Types
         - Categorical semantics: LJ ↔ CCC, LL ↔ *-Autonomous
         - Code listing: Curry-Howard RDF
      7. section{Reusable Categorical Ontologies} (60 lines):
         - Inventory of 11+ external resources
         - Table: resource license compatibility
         - DBPedia, Wikidata, OpenMath, COLORE, nLab, HoTT, Coq, Lean, Isabelle, ProofWiki, OMDoc
         - Integration roadmap (4 phases)
      8. section{SPARQL Query Examples} (30 lines):
         - Example queries for ontology exploration
         - Code listing: SPARQL query
      9. section{Conclusion} (20 lines):
         - Summary of deliverables
         - Contributions to categorical logic formalization
         - Future work
      Formatting requirements:
      - Use lstlisting or verbatim for code (RDF, SPARQL)
      - Use tabular for tables
      - Use cite commands for references
      - Use texttt for URIs and technical terms
      Output: thesis/chapters/categorical-semantic-audit.tex (minimum 350 lines).
    acceptance_criteria:
      - "file thesis/chapters/categorical-semantic-audit.tex exists"
      - "valid LaTeX syntax"
      - "contains chapter{Categorical Semantic Audit} command"
      - "contains at least 7 sections as specified"
      - "includes code listings (lstlisting or verbatim)"
      - "includes tables (tabular)"
      - "minimum 300 lines"
      - "validates against .catty/validation/thesis-structure.json (once schema exists)"
    validation_script: ".catty/validation/validate.py --artifact audit-chapter"

  write-conclusions:
    task_id: "task:write-conclusions"
    phase: 2
    produces: ["conclusions-chapter"]
    depends_on: ["write-audit-chapter"]
    description: |
      Write conclusions chapter for thesis in LaTeX format.
      Structure:
      - chapter{Conclusions}
      - section{Summary} (40 lines):
        - Categorical modeling of formal logics
        - Two-dimensional lattice structure
        - Morphism catalog
        - Curry-Howard correspondence
        - RDF/OWL knowledge graph
        - External resource integration
      - section{Contributions} (30 lines):
        - Formal categorical framework for logics
        - Machine-readable ontology
        - SHACL validation and SPARQL queries
        - Reusable semantic web resources
      - section{Future Work} (40 lines):
        - Extension to modal and higher-order logics
        - Automated proof system integration
        - Triplestore deployment and web interface
        - Category theory formalization in proof assistants (Coq, Lean)
      Output: thesis/chapters/conclusions.tex (minimum 100 lines).
    acceptance_criteria:
      - "file thesis/chapters/conclusions.tex exists"
      - "valid LaTeX syntax"
      - "contains chapter{Conclusions} command"
      - "contains at least 3 sections: Summary, Contributions, Future Work"
      - "minimum 90 lines"
    validation_script: ".catty/validation/validate.py --artifact conclusions-chapter"

  build-thesis-pdf:
    task_id: "task:build-thesis-pdf"
    phase: 2
    produces: ["thesis-pdf"]
    depends_on: ["thesis-main", "thesis-preamble", "introduction-chapter", "audit-chapter", "conclusions-chapter"]
    description: |
      Compile LaTeX thesis to PDF.
      Commands:
      - cd thesis/
      - make (uses Makefile with pdflatex or latexmk)
      - Ensure compilation succeeds (exit code 0)
      - Verify output PDF exists: thesis/main.pdf
      Note: Do not commit generated PDF to git (add to .gitignore).
    acceptance_criteria:
      - "file thesis/main.pdf exists"
      - "PDF is valid (can be opened)"
      - "pdflatex or latexmk compilation succeeds with exit code 0"
      - "PDF contains all chapters: Introduction, Categorical Semantic Audit, Conclusions"
      - "no critical LaTeX errors (missing references are warnings, not errors)"
    validation_script: ".catty/validation/validate.py --artifact thesis-pdf"

  # --------------------------------------------------------------------------
  # GitHub Pages Tasks (Phase 2 continued)
  # --------------------------------------------------------------------------

  expand-latex:
    task_id: "task:expand-latex"
    phase: 2
    produces: ["thesis-expanded-latex"]
    depends_on: ["thesis-main", "thesis-preamble", "introduction-chapter", "audit-chapter", "conclusions-chapter"]
    description: |
      Expand LaTeX main.tex file with all includes expanded inline.
      Use latexpand tool to recursively expand \input and \include commands.
      Commands:
      - mkdir -p site/
      - cd thesis/
      - latexpand main.tex > ../site/main.expanded.tex
      Verify no \input or \include commands remain in expanded file.
      Output: site/main.expanded.tex (intermediate file for Pandoc).
      Note: This is required because Pandoc cannot follow LaTeX includes.
    acceptance_criteria:
      - "file site/main.expanded.tex exists"
      - "valid LaTeX syntax"
      - "expanded file contains all chapter content inline"
      - "no \\input or \\include commands remain (grep returns no matches)"
      - "file size > 20KB (contains substantial content)"
    validation_script: "grep -E '\\\\(input|include)' site/main.expanded.tex && exit 1 || exit 0"

  convert-latex-to-html:
    task_id: "task:convert-latex-to-html"
    phase: 2
    produces: ["thesis-html"]
    depends_on: ["thesis-expanded-latex"]
    description: |
      Convert expanded LaTeX to HTML5 using Pandoc.
      Pandoc converts LaTeX to semantic HTML with proper structure.
      Commands:
      - mkdir -p site/
      - pandoc -f latex -t html -s site/main.expanded.tex -o site/index.html
      Options:
      - -f latex: input format is LaTeX
      - -t html: output format is HTML
      - -s: standalone (complete HTML document with <html>, <head>, <body>)
      Output: site/index.html (complete HTML thesis).
    acceptance_criteria:
      - "file site/index.html exists"
      - "valid HTML5 syntax"
      - "HTML contains thesis chapters and sections"
      - "HTML contains proper headings (h1, h2, h3)"
      - "file size > 10KB (substantial content)"
      - "HTML contains title and content from thesis"
    validation_script: ".catty/validation/validate.py --artifact thesis-html"

  build-github-pages-site:
    task_id: "task:build-github-pages-site"
    phase: 2
    produces: ["github-pages-site"]
    depends_on: ["thesis-pdf", "thesis-html"]
    description: |
      Assemble complete GitHub Pages site directory.
      Copy artifacts to site/ directory:
      - site/index.html already exists (from convert-latex-to-html)
      - cp thesis/main.pdf site/main.pdf
      Verify both files exist and are non-empty.
      Directory structure:
      site/
      ├── index.html  (HTML thesis)
      └── main.pdf    (PDF thesis)
      Output: site/ directory ready for GitHub Pages deployment.
      Note: The GitHub Actions workflow handles upload and deployment.
    acceptance_criteria:
      - "directory site/ exists"
      - "file site/index.html exists and is valid HTML"
      - "file site/main.pdf exists and is valid PDF"
      - "both files are non-empty (size > 1KB)"
      - "site is ready for upload-pages-artifact action"
    validation_script: "ls -lh site/index.html site/main.pdf && test -s site/index.html && test -s site/main.pdf"

  create-github-pages-workflow:
    task_id: "task:create-github-pages-workflow"
    phase: 2
    produces: ["github-pages-workflow"]
    depends_on: []
    description: |
      Create GitHub Actions workflow for GitHub Pages deployment.
      File: .github/workflows/deploy.yml
      Workflow structure:
      - name: Deploy
      - on: workflow_dispatch (manual trigger from GitHub UI)
      - permissions: contents:read, pages:write, id-token:write
      - jobs:
        - build-and-deploy:
          - runs-on: ubuntu-latest
          - steps:
            1. Check out repository (actions/checkout@v4)
            2. Install LaTeX + Pandoc (apt-get install)
               - texlive-latex-base, texlive-latex-recommended, texlive-latex-extra
               - texlive-pictures, texlive-fonts-recommended, texlive-extra-utils
               - pandoc, latexpand
            3. Build PDF (cd thesis && make clean && make)
            4. Expand LaTeX (latexpand main.tex > ../site/main.expanded.tex)
            5. Convert to HTML (pandoc -f latex -t html -s ...)
            6. Copy PDF to site (cp main.pdf ../site/main.pdf)
            7. Configure GitHub Pages (actions/configure-pages@v5)
            8. Upload Pages artifact (actions/upload-pages-artifact@v3, path: site)
            9. Deploy to GitHub Pages (actions/deploy-pages@v4)
      Output: .github/workflows/deploy.yml
    acceptance_criteria:
      - "file .github/workflows/deploy.yml exists"
      - "valid YAML syntax"
      - "contains on: workflow_dispatch trigger"
      - "contains jobs with build-and-deploy"
      - "installs LaTeX, Pandoc, latexpand in workflow"
      - "builds PDF using make"
      - "expands LaTeX using latexpand"
      - "converts to HTML using pandoc"
      - "uses configure-pages, upload-pages-artifact, deploy-pages actions"
      - "sets correct permissions (pages:write, id-token:write)"
    validation_script: ".catty/validation/validate.py --artifact github-pages-workflow"

  deploy-to-github-pages:
    task_id: "task:deploy-to-github-pages"
    phase: 2
    produces: []
    depends_on: ["github-pages-site", "github-pages-workflow"]
    description: |
      Deploy site to GitHub Pages using GitHub Actions workflow.
      This task is primarily automated via .github/workflows/deploy.yml.
      
      Manual execution:
      1. Push changes to GitHub (including workflow file)
      2. Go to GitHub repository
      3. Click "Actions" tab
      4. Select "Deploy" workflow
      5. Click "Run workflow" button
      6. Select branch (usually main)
      7. Click "Run workflow" button
      
      Workflow performs:
      1. Builds PDF from LaTeX source
      2. Expands LaTeX with latexpand
      3. Converts to HTML with Pandoc
      4. Copies PDF and HTML to site/
      5. Uploads site/ as Pages artifact
      6. Deploys to GitHub Pages
      
      Result: Thesis accessible at https://metavacua.github.io/CategoricalReasoner/
      - index.html: HTML version of thesis
      - main.pdf: PDF version of thesis (downloadable)
      
      Verification:
      - Check GitHub Actions tab for successful workflow run
      - Visit https://metavacua.github.io/CategoricalReasoner/ to verify deployment
      - Verify both HTML and PDF are accessible
      
      Note: First deployment requires enabling GitHub Pages in repository settings:
      Settings → Pages → Build and deployment → Source: GitHub Actions
    acceptance_criteria:
      - "workflow file .github/workflows/deploy.yml exists"
      - "site/ directory exists with index.html and main.pdf"
      - "workflow can be triggered manually from GitHub UI"
      - "workflow runs successfully (check GitHub Actions tab)"
      - "GitHub Pages site is accessible at https://metavacua.github.io/CategoricalReasoner/"
      - "HTML thesis is viewable at site root"
      - "PDF thesis is downloadable from /main.pdf"
    validation_script: "echo 'Manual verification required: 1) Run workflow from GitHub UI, 2) Check https://metavacua.github.io/CategoricalReasoner/, 3) Verify HTML and PDF are accessible'"

  # --------------------------------------------------------------------------
  # Phase 3: Validation Framework Tasks
  # --------------------------------------------------------------------------

  build-validation-framework:
    task_id: "task:build-validation-framework"
    phase: 3
    produces: ["validation-script", "categorical-schema-shape", "logics-as-objects-shape", "morphism-catalog-shape", "two-d-lattice-shape", "curry-howard-model-shape", "complete-example-shape", "thesis-structure-schema"]
    depends_on: ["catty-categorical-schema"]
    description: |
      Create comprehensive validation framework for task outputs.
      1. Python validation script (.catty/validation/validate.py):
         - Import libraries: rdflib, pyshacl, json, yaml, argparse, sys, os
         - Function: validate_rdf(file_path, shape_file) -> bool, errors
           - Load RDF file using rdflib
           - Load SHACL shape file
           - Validate using pyshacl
           - Return boolean and error messages
         - Function: validate_json_ld(file_path) -> bool, errors
           - Parse JSON-LD using json
           - Validate @context presence
           - Validate required keys
           - Return boolean and error messages
         - Function: validate_latex(file_path, structure_schema) -> bool, errors
           - Read LaTeX file
           - Check for chapter/section commands
           - Count lines
           - Validate against structure schema (JSON)
           - Return boolean and error messages
         - Function: validate_artifact(artifact_id, operations_yaml_path)
           - Read operations.yaml
           - Get artifact specification
           - Call appropriate validation function
           - Print results
         - CLI: python validate.py --artifact <artifact_id> [--operations <path>]
      2. SHACL shape files (.catty/validation/shapes/*.shacl):
         - categorical-schema.shacl: NodeShapes for Category, Object, Morphism, Logic
         - logics-as-objects.shacl: Logic instance requirements
         - morphism-catalog.shacl: Morphism instance requirements
         - two-d-lattice-category.shacl: Lattice node and order requirements
         - curry-howard-model.shacl: CurryHowardEquivalence requirements
         - complete-example.shacl: Complete example validation
      3. JSON Schema (.catty/validation/thesis-structure.json):
         - Define chapter structure requirements
         - Audit chapter: 7+ sections, 300+ lines, code listings, tables
         - Introduction: 3+ sections, 60+ lines
         - Conclusions: 3+ sections, 90+ lines
      Output: .catty/validation/validate.py, .catty/validation/shapes/*.shacl,
              .catty/validation/thesis-structure.json.
    acceptance_criteria:
      - "file .catty/validation/validate.py exists"
      - "valid Python syntax"
      - "defines functions: validate_rdf, validate_json_ld, validate_latex, validate_artifact"
      - "has CLI entry point (if __name__ == '__main__')"
      - "imports required libraries: rdflib, json, yaml, argparse"
      - "file .catty/validation/shapes/categorical-schema.shacl exists (valid Turtle)"
      - "file .catty/validation/shapes/logics-as-objects.shacl exists (valid Turtle)"
      - "file .catty/validation/shapes/morphism-catalog.shacl exists (valid Turtle)"
      - "file .catty/validation/shapes/two-d-lattice-category.shacl exists (valid Turtle)"
      - "file .catty/validation/shapes/curry-howard-model.shacl exists (valid Turtle)"
      - "file .catty/validation/shapes/complete-example.shacl exists (valid Turtle)"
      - "file .catty/validation/thesis-structure.json exists (valid JSON Schema)"
    validation_script: "python .catty/validation/validate.py --artifact validation-script"

  validate-ontology:
    task_id: "task:validate-ontology"
    phase: 3
    produces: []
    depends_on: ["build-validation-framework", "catty-categorical-schema", "logics-as-objects", "morphism-catalog", "two-d-lattice-category", "curry-howard-categorical-model", "catty-complete-example", "catty-shapes"]
    description: |
      Validate all ontology artifacts using validation framework.
      Run validation for each artifact:
      - python .catty/validation/validate.py --artifact catty-categorical-schema
      - python .catty/validation/validate.py --artifact logics-as-objects
      - python .catty/validation/validate.py --artifact morphism-catalog
      - python .catty/validation/validate.py --artifact two-d-lattice-category
      - python .catty/validation/validate.py --artifact curry-howard-categorical-model
      - python .catty/validation/validate.py --artifact catty-complete-example
      - python .catty/validation/validate.py --artifact catty-shapes
      All validations must pass (return true).
      If validation fails, fix artifacts and re-validate.
    acceptance_criteria:
      - "all ontology artifacts validate successfully"
      - "catty-categorical-schema validation passes"
      - "logics-as-objects validation passes"
      - "morphism-catalog validation passes"
      - "two-d-lattice-category validation passes"
      - "curry-howard-categorical-model validation passes"
      - "catty-complete-example validation passes"
      - "catty-shapes validation passes (syntax check)"
    validation_script: "python .catty/validation/validate.py --artifact ontology-readme"

  validate-thesis:
    task_id: "task:validate-thesis"
    phase: 3
    produces: []
    depends_on: ["build-validation-framework", "audit-chapter", "introduction-chapter", "conclusions-chapter"]
    description: |
      Validate thesis artifacts using validation framework.
      Run validation for each chapter:
      - python .catty/validation/validate.py --artifact audit-chapter
      - python .catty/validation/validate.py --artifact introduction-chapter
      - python .catty/validation/validate.py --artifact conclusions-chapter
      All validations must pass (return true).
      Validate thesis compiles successfully:
      - cd thesis/ && make clean && make
      - Exit code must be 0
      If validation fails, fix chapters and re-validate.
    acceptance_criteria:
      - "all thesis chapters validate successfully"
      - "audit-chapter validation passes"
      - "introduction-chapter validation passes"
      - "conclusions-chapter validation passes"
      - "thesis compiles to PDF without errors"
    validation_script: "cd thesis && make"

# ==============================================================================
# PART 3: TASK EXECUTION METADATA
# ==============================================================================

execution_metadata:
  task_template:
    description: "Template for task execution by coding agent"
    required_fields:
      - task_id
      - phase
      - produces
      - depends_on
      - description
      - acceptance_criteria
      - validation_script
    execution_steps:
      - "Read task description (operational instructions)"
      - "Check dependencies (all depends_on artifacts must exist)"
      - "Execute task according to description"
      - "Produce artifacts according to content_spec"
      - "Run acceptance criteria checks"
      - "Run validation_script"
      - "If validation fails, iterate until pass"
    agent_instructions: |
      To execute a task:
      1. Parse task from operations.yaml by task_id
      2. Verify all dependencies exist (check depends_on artifacts)
      3. Read artifact specifications for produces (content_spec, format, schema)
      4. Execute task description (operational steps, not aspirational goals)
      5. Create artifact files at specified paths
      6. Validate output against acceptance_criteria (boolean checks)
      7. Run validation_script if provided
      8. If any criteria fail, iterate on artifacts until all pass
      9. Do not proceed to next task until current task passes all validations

  validation_instructions:
    rdf_artifacts:
      - "Parse RDF file using rdflib (Turtle or JSON-LD format)"
      - "Validate against SHACL shape file using pyshacl"
      - "Check for required classes, properties, datatypes"
      - "Verify no SHACL violations"
    json_ld_artifacts:
      - "Parse JSON-LD file using json library"
      - "Validate @context presence and required prefixes"
      - "Check for required keys in JSON structure"
      - "Validate against SHACL if applicable"
    latex_artifacts:
      - "Read LaTeX file as text"
      - "Check for required commands (chapter, section, begin/end document)"
      - "Count lines (minimum line requirements)"
      - "Check for code listings (lstlisting, verbatim)"
      - "Check for tables (tabular)"
      - "Validate against structure schema (JSON)"
      - "Attempt compilation (pdflatex or latexmk) for final validation"
    markdown_artifacts:
      - "Read Markdown file as text"
      - "Check for required sections (# headings)"
      - "Count lines (minimum line requirements)"
      - "Check for code blocks (``` fences)"
      - "Check for tables (Markdown table syntax)"
      - "Validate content requirements (keywords, structure)"

  artifact_dependency_resolution:
    description: "How to resolve artifact dependencies when executing tasks"
    rules:
      - "Before executing task, check all depends_on artifacts exist"
      - "If artifact does not exist, find task that produces it"
      - "Execute dependency task first (recursive)"
      - "If dependency task has dependencies, resolve those first"
      - "Build dependency graph and execute in topological order"
      - "Tasks in same phase with no interdependencies can run in parallel"

  error_handling:
    validation_failure:
      - "If validation fails, read error messages"
      - "Identify which acceptance criteria failed"
      - "Modify artifact to satisfy failed criteria"
      - "Re-run validation"
      - "Iterate until all criteria pass"
      - "Do not proceed to next task if validation fails"
    missing_dependency:
      - "If depends_on artifact missing, execute task that produces it"
      - "If dependency task fails, do not proceed with current task"
      - "Report missing dependency to user if cannot be resolved"
    syntax_error:
      - "If artifact has syntax error (RDF, JSON, LaTeX), fix syntax"
      - "Use appropriate parser to validate syntax"
      - "Re-run validation after fix"

# ==============================================================================
# METADATA
# ==============================================================================

changelog:
  - version: "1.0.1"
    date: "2025-01-03"
    changes: |
      Added GitHub Pages deployment artifacts and tasks:
      - Added 4 new artifacts: thesis-expanded-latex, thesis-html, github-pages-site, github-pages-workflow
      - Added 5 new tasks: expand-latex, convert-latex-to-html, build-github-pages-site, create-github-pages-workflow, deploy-to-github-pages
      - Added semantic_web_technologies section to metadata documenting RDF/OWL, SHACL, SPARQL, and deployment technologies
      - Updated thesis-pdf consumed_by to include GitHub Pages site building
      - Aligned operational model with actual .github/workflows/deploy.yml implementation
      - Documented Pandoc HTML conversion and latexpand preprocessing
      - Clarified SPARQL examples are documentation, not executable benchmarks
      - Noted triplestore deployment removed (not part of core deliverables)
  - version: "1.0.0"
    date: "2025-01-02"
    changes: "Initial operational model with complete artifact and task registries for Phases 0-3"
